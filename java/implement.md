# 구현

## 추상 메소드만 담고 있는 인터페이스

- 추상 메소드(Abstract Methods)
    - 메소드의 몸체가 비어 있는 메소드

## 인터페이스의 특징

1. 인터페이스의 형을 대상으로 참조변수의 선언이 가능하다
2. 인터페이스의 추상 메소드와 이를 구현하는 메소드 사이에 오버라이딩 관계가 성립한다
    1. `@Override` 선언

## 인터페이스의 본질적 의미

- 사전적 의미
    - '연결점' 또는 '접점'으로 둘 사이를 연결하는 매개체
- 사용자는 구현된 클래스의 이름만 알면 될 뿐, 내부적으로 구현이 어떻게 이뤄지는지는 알 필요가 없다
- 사용자 입장에서는 내부적 구조에 대한 이해 없이 약속된 행위가 보장된다(추상화)

## 인터페이스의 문법

- 메소드
    - 모든 메소드는 `public`이 선언된 것으로 간주
    - `abstract` 생략
- 변수
    - 반드시 선언과 동시에 값으로 초기화
    - 모든 변수는 `public`, `static`, `final`이 선언된 것으로 간주
- 구현
    - 클래스 `implements` 인터페이스
    - 인터페이스를 구현하는 클래스는 인터페이스에 존재하는 모든 '추상 메소드'를 구현해야 한다.
    - 다 채워서 구현해야지 인스턴스 생성이 가능하다.
- 상속
    - 인터페이스 `extends` 인터페이스
- `instanceof`
    - 직접 혹은 간접적으로 구현한 클래스의 인스턴스인 경우를 체크

## 디폴트 메소드

- 이미 정의되서 사용중인 인터페이스에 추상 메소드를 하나 추가하게 된다면
    - ex) 자바 8에서 '람다'를 지원하기 위해 추상 메소드 추가
- 인터페이스간 상속을 이용하게되면 인터페이스의 수가 늘어남
- 디폴트 메소드의 등장

- 특징
    1. 자체로 완전한 메소드
    2. 이를 구현하는 클래스가 오버라이딩 하지 않아도 된다

## static 메소드(클래스 메소드)

- 자바 8부터 인터페이스에도 `static` 메소드를 둘 수 있게 되었다.
- 자바 제공 인터페이스에서 정의된 경우가 있음. 프로그래머는 잘 사용하지 않음.
- 인터페이스의 `static` 메소드 호출 방법은 클래스의 `static` 메소드 호출 방법과 같다.

## 마커 인터페이스

- 구현해야할 메소드는 존재하지 않음
- `instanceof`를 활용

## 추상 클래스(Abstract Class)

- 하나 이상의 추상 메소드를 갖는 클래스
- 클래스 선언 시 `abstract` 선언 추가
- 인터페이스와 유사하지만 다름
- 인스턴스 생성 불가능
- 구현이 필요함, 그럼에도 불구하고 인터페이스가 아닌 클래스이기 때문에 상속의 형태를 띔

## 추상 클래스 vs 인터페이스

- 비슷한 점
    - 추상 메소드를 구현한다는 점에서 비슷한 역할을 한다.

- 차이점
    - 추상 __클래스__ 는 상속을 통해 기능을 확장하는데 목적이 있고
    - 인터페이스는 구현을 강제로 하여 구현한 객체들에 대하여 동일한 동작의 보장에 목적이 있다
    - 추상 __클래스__ 는 다중 상속을 하지 못한다
        - 왜? 슈퍼클래스의 기능을 상속하여 확장하는데 목적이 있기 때문에, 여러 기능을 상속할 경우에는 확장을 하는데에 모호함이 생긴다
        - 구체적인 선언부가 존재하기에 모호함이 생김
        - 추상메소드 선언 + 다른 일반 메소드나 필드도 필요
    - 인터페이스는 다중 상속이 가능하다
        - 왜? 기능을 상속하여 확장하는데에 목적이 있는 게 아니라, 구현한 객체들에 대하여 동일한 동작의 보장에 목적이 있기 때문
        - 구체적인 선언부가 없기에 모호함이 없음
        - 추상메소드만 선언
        - 추상메소드 보다 좀 더 유연하게 다형성을 적용 할 수 있다.

- 언제 사용해야하는가
  - 추상클래스 : 추상메소드 이외에 다른 일반 메소드나 필드도 필요
    1. 굉장이 밀접하게 관련된 클래스끼리 코드를 공유해야 할 때
    2. 추상클래스의 하위 구현체들이 공통된 필드나 메서드를 많이 공유하고, 접근제어자가 public이 아닌 경우
    3. non-static, non-final의 필드로 객체의 상태를 바꿔야 하는 경우
  - 인터페이스 : 다중 상속
    1. 관련이 없는 클래스들끼리 관계를 맺어줄 때
    2. 특정 데이터 타입의 동작을 지정하려고 하지만 해당 동작을 누가 구현하는지는 중요하지 않을 때
    3. 다중 상속이 필요할 때

## 추상 골격 클래스(Skeletal Implementation)

- `AbstractList`, `AbstractMap`
- 중복되는 메서드를 공통으로 갖는 추상 클래스 구현
  - 하위 클래스의 중복 코드가 사라짐
- `interface`의 `default method`와의 차이점
  - 추상 골격 클래스
    - `private`, `protected` 가능
    - 하위 구현체 클래스에 대한 상태, 필드에 대한 참조가 가능
  - 인터페이스
    - `public`
      - 은닉이 어려움
    - 하위 구현체 클래스에 대한 상태, 필드에 대한 참조가 불가능
    - 도입취지는 존재하는 인터페이스의 하위호환성을 위함임
      - 즉, 아예 새로운 인터페이스를 만들 때는 default method의 도입취지와는 맞지 않음

## Interface를 쓸 때 유의할 점

- `default method` override
  - ex) `Collection`의 `removeIf`는 멀티 Thread 환경에서 차이가 있음 그렇기에 `synchronized` lock를 하는 식으로 override를 함
  - 이 때 다이아몬드 문제가 발생할 수 있음
    - 우선순위를 두어서 해결함
      1. 구현하는 클래스나 슈퍼클래스
      2. 상속받는 인터페이스
      3. 명시적 사용
- `default method`
  - 런타임 오류를 발생시킬 수 있다
  - 이미 구현된 인터페이스에 디폴트 메서드를 추가하는 것은 신중히 해야 한다
  - 추가 시 반드시 테스트가 필요

## 참고

- 열혈 Java 프로그래밍, 윤성우 저
- [https://brunch.co.kr/@kd4/6](https://brunch.co.kr/@kd4/6)
- [http://alecture.blogspot.com/2011/05/abstract-class-interface.html](http://alecture.blogspot.com/2011/05/abstract-class-interface.html)
- [https://www.youtube.com/watch?v=T1BJzC9xb0g](https://www.youtube.com/watch?v=T1BJzC9xb0g)